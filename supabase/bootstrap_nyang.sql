-- Bootstrap Nyaru Schema (Consolidated v2)
-- Includes migrations 001 through 011
-- Target schema: nyang

-- 1. Schema Setup
create schema if not exists nyang;

grant usage on schema nyang to postgres, anon, authenticated, service_role;
grant all privileges on all tables in schema nyang to postgres, anon, authenticated, service_role;
grant all privileges on all functions in schema nyang to postgres, anon, authenticated, service_role;
grant all privileges on all sequences in schema nyang to postgres, anon, authenticated, service_role;

create extension if not exists pgcrypto;

-- 2. Types
do $$ begin
  create type nyang.role_sync_job_status as enum ('pending', 'processing', 'completed', 'failed');
exception when duplicate_object then null; end $$;

do $$ begin
  create type nyang.gacha_pool_kind as enum ('permanent', 'limited');
exception when duplicate_object then null; end $$;

do $$ begin
  create type nyang.gacha_rarity as enum ('R', 'S', 'SS', 'SSS');
exception when duplicate_object then null; end $$;

-- 3. Tables

-- App Config
create table if not exists nyang.app_config (
  id integer primary key generated by default as identity,
  guild_id text not null,
  admin_role_ids text[] default array[]::text[],
  
  -- Join Message
  join_message_template text,
  join_message_channel_id text,
  
  -- Rewards
  reward_points_per_interval integer default 10,
  reward_interval_seconds integer default 60,
  reward_min_message_length integer default 5,
  reward_daily_cap_points integer,
  
  -- Server Info (Web)
  server_intro text,
  banner_image_url text,
  icon_image_url text,
  
  -- Bot Settings
  bot_sync_interval_ms integer default 5000,
  persona_prompt text,
  reward_emoji_enabled boolean default true,
  error_log_channel_id text,
  show_traceback_to_user boolean default true,
  last_heartbeat_at timestamptz,
  
  -- Gacha Embed Settings
  gacha_embed_title text default 'ðŸŽ° ê°€ì±  ë½‘ê¸°',
  gacha_embed_color text default '#5865F2',
  gacha_embed_description text default 'í˜„ìž¬ í¬ì¸íŠ¸: {points}p...',
  gacha_processing_title text default 'ðŸŽ² ë½‘ëŠ” ì¤‘...',
  gacha_processing_description text default '{drawCount}íšŒ ë½‘ê¸°ë¥¼ ì§„í–‰í•˜ê³  ìžˆìŠµë‹ˆë‹¤...',
  gacha_result_title text default 'ðŸŽ‰ {drawCount}íšŒ ë½‘ê¸° ê²°ê³¼',
  
  -- Inventory Embed Settings (011)
  inventory_embed_title text default 'ðŸŽ’ ì¸ë²¤í† ë¦¬',
  inventory_embed_color text default '#5865F2',
  inventory_embed_description text default '{user}ë‹˜ì˜ ì¸ë²¤í† ë¦¬ìž…ë‹ˆë‹¤.\ní˜„ìž¬ í¬ì¸íŠ¸: **{points}p**',
  
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Reward Channels Whitelist
create table if not exists nyang.reward_channels (
  channel_id text primary key,
  name text,
  enabled boolean default true,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Users
create table if not exists nyang.users (
  discord_user_id text primary key,
  username text,
  avatar_url text,
  created_at timestamptz default now(),
  last_seen_at timestamptz
);

-- Point Balances
create table if not exists nyang.point_balances (
  discord_user_id text primary key references nyang.users(discord_user_id) on delete cascade,
  balance integer default 0,
  updated_at timestamptz default now()
);

-- Point Events (Logs)
create table if not exists nyang.point_events (
  id uuid primary key default gen_random_uuid(),
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  kind text not null, -- 'chat_grant', 'gacha_cost', 'admin_grant'
  amount integer not null,
  idempotency_key text unique, -- for dedup
  meta jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

create index if not exists point_events_user_time_idx on nyang.point_events(discord_user_id, created_at desc);

-- Items (Gacha Rewards)
create table if not exists nyang.items (
  item_id uuid primary key default gen_random_uuid(),
  name text not null,
  description text,
  rarity nyang.gacha_rarity not null, -- 'R', 'S', 'SS', 'SSS'
  image_url text,
  discord_role_id text, -- Role to give when equipped
  probability double precision not null default 0, -- 0-100 (weight) NOT USED IN LOGIC YET, using gacha_pool_items weight
  is_active boolean default true,
  is_equippable boolean default true,
  duplicate_refund_points integer default 0,
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  constraint items_discord_role_unique unique (discord_role_id)
);

-- Gacha Pools
create table if not exists nyang.gacha_pools (
  pool_id uuid primary key default gen_random_uuid(),
  name text not null,
  kind nyang.gacha_pool_kind not null default 'permanent',
  description text,
  cost_points integer default 100,
  is_active boolean default true,
  banner_image_url text,
  paid_pull_cooldown_seconds integer default 0,
  free_pull_interval_seconds integer,
  rate_r numeric(5,2) not null default 5,
  rate_s numeric(5,2) not null default 75,
  rate_ss numeric(5,2) not null default 17,
  rate_sss numeric(5,2) not null default 3,
  pity_threshold integer,
  pity_rarity nyang.gacha_rarity,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  constraint gacha_pools_rate_sum_check check (rate_r + rate_s + rate_ss + rate_sss = 100)
);

-- Gacha Pool Items (Many-to-Many)
create table if not exists nyang.gacha_pool_items (
  pool_id uuid references nyang.gacha_pools(pool_id) on delete cascade,
  item_id uuid references nyang.items(item_id) on delete cascade,
  weight integer default 1,
  primary key (pool_id, item_id)
);

-- Gacha User State (Pity System)
create table if not exists nyang.gacha_user_state (
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  pool_id uuid not null references nyang.gacha_pools(pool_id) on delete cascade,
  pity_counter integer default 0,
  free_available_at timestamptz,
  paid_available_at timestamptz,
  total_pulls integer default 0,
  updated_at timestamptz default now(),
  primary key (discord_user_id, pool_id)
);

-- Gacha Pull History (Master)
create table if not exists nyang.gacha_pulls (
  pull_id uuid primary key default gen_random_uuid(),
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  pool_id uuid not null references nyang.gacha_pools(pool_id) on delete cascade,
  is_free boolean default false,
  spent_points integer not null default 0, -- renamed from cost
  created_at timestamptz default now()
);

create index if not exists gacha_pulls_user_time_idx on nyang.gacha_pulls(discord_user_id, created_at desc);

-- Gacha Pull Results (Items won in a pull)
create table if not exists nyang.gacha_pull_results (
  id uuid primary key default gen_random_uuid(), -- added ID for easier ref
  pull_id uuid not null references nyang.gacha_pulls(pull_id) on delete cascade,
  item_id uuid not null references nyang.items(item_id) on delete cascade,
  qty integer default 1,
  is_pity boolean default false,
  created_at timestamptz default now()
  -- removed primary key (pull_id, item_id) to allow multiples if needed, though logic merges them usually
);

-- Inventory (User Items)
create table if not exists nyang.inventory (
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  item_id uuid not null references nyang.items(item_id) on delete cascade,
  qty integer default 0,
  updated_at timestamptz default now(),
  primary key (discord_user_id, item_id),
  constraint inventory_qty_nonnegative check (qty >= 0)
);

-- Equipped Items
create table if not exists nyang.equipped (
  discord_user_id text primary key references nyang.users(discord_user_id) on delete cascade,
  item_id uuid references nyang.items(item_id) on delete set null,
  equipped_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Role Sync Jobs (Async worker queue)
create table if not exists nyang.role_sync_jobs (
  job_id uuid primary key default gen_random_uuid(),
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  target_role_ids text[] default array[]::text[],
  add_role_id text, -- for specific action logging
  remove_role_id text, -- for specific action logging
  reason text default '',
  status nyang.role_sync_job_status default 'pending',
  error text,
  attempts integer default 0,
  last_error text,
  created_at timestamptz default now(),
  processed_at timestamptz,
  updated_at timestamptz default now()
);

create index if not exists role_sync_jobs_status_idx on nyang.role_sync_jobs(status, created_at);

-- 4. RLS Policies (Enable RLS on all tables)
alter table nyang.app_config enable row level security;
alter table nyang.reward_channels enable row level security;
alter table nyang.users enable row level security;
alter table nyang.point_balances enable row level security;
alter table nyang.point_events enable row level security;
alter table nyang.items enable row level security;
alter table nyang.gacha_pools enable row level security;
alter table nyang.gacha_pool_items enable row level security;
alter table nyang.gacha_user_state enable row level security;
alter table nyang.gacha_pulls enable row level security;
alter table nyang.gacha_pull_results enable row level security;
alter table nyang.inventory enable row level security;
alter table nyang.equipped enable row level security;
alter table nyang.role_sync_jobs enable row level security;

-- Create policies (Public read, Service role all)
do $$ begin
  create policy "Public read app_config" on nyang.app_config for select using (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "Service write app_config" on nyang.app_config for all using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "Public read items" on nyang.items for select using (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "Public read gacha_pools" on nyang.gacha_pools for select using (true);
exception when duplicate_object then null; end $$;

-- User data policies (simplified for dev - allow service role everything)
do $$ begin
  create policy "Service role full access users" on nyang.users for all using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "Service role full access balances" on nyang.point_balances for all using (true) with check (true);
exception when duplicate_object then null; end $$;

do $$ begin
  create policy "Service role full access inventory" on nyang.inventory for all using (true) with check (true);
exception when duplicate_object then null; end $$;

-- 5. Functions

-- Helper: Ensure user exists
create or replace function nyang.ensure_user(p_discord_user_id text)
returns void
language plpgsql
set search_path = nyang, public
as $$
begin
  insert into users(discord_user_id) values (p_discord_user_id)
  on conflict (discord_user_id) do update set last_seen_at = now();
  
  insert into point_balances(discord_user_id, balance) values (p_discord_user_id, 0)
  on conflict (discord_user_id) do nothing;
end;
$$;

-- Grant Chat Points (Strict Whitelist Check)
create or replace function nyang.grant_chat_points(
  p_discord_user_id text,
  p_channel_id text,
  p_message_length integer,
  p_message_ts timestamptz,
  p_message_id text default null
)
returns table (
  granted_points integer,
  new_balance integer
)
language plpgsql
set search_path = nyang, public
as $$
declare
  v_cfg app_config%rowtype;
  v_enabled boolean;
  v_bucket_start timestamptz;
  v_key text;
  v_daily_sum integer;
begin
  perform ensure_user(p_discord_user_id);

  select * into v_cfg from app_config where id = 1;
  if not found then
    raise exception 'CONFIG_MISSING';
  end if;

  -- [STRICT CHECK] Explicitly initialize to false
  v_enabled := false;

  select enabled into v_enabled
  from reward_channels
  where channel_id = p_channel_id;

  -- If channel not found OR not enabled, return 0
  if v_enabled is not true then
    granted_points := 0;
    select balance into new_balance from point_balances where discord_user_id = p_discord_user_id;
    return next;
  end if;

  if p_message_length < v_cfg.reward_min_message_length then
    granted_points := 0;
    select balance into new_balance from point_balances where discord_user_id = p_discord_user_id;
    return next;
  end if;

  v_bucket_start := to_timestamp(floor(extract(epoch from p_message_ts) / v_cfg.reward_interval_seconds) * v_cfg.reward_interval_seconds);
  v_key := 'chat:' || p_discord_user_id || ':' || p_channel_id || ':' || extract(epoch from v_bucket_start)::bigint::text;

  if v_cfg.reward_daily_cap_points is not null then
    select coalesce(sum(amount), 0) into v_daily_sum
    from point_events
    where discord_user_id = p_discord_user_id
      and kind = 'chat_grant'
      and created_at >= date_trunc('day', p_message_ts);

    if v_daily_sum >= v_cfg.reward_daily_cap_points then
      granted_points := 0;
      select balance into new_balance from point_balances where discord_user_id = p_discord_user_id;
      return next;
    end if;
  end if;

  insert into point_events(discord_user_id, kind, amount, idempotency_key, meta)
  values (
    p_discord_user_id,
    'chat_grant',
    v_cfg.reward_points_per_interval,
    v_key,
    jsonb_build_object('channel_id', p_channel_id, 'message_id', p_message_id, 'bucket_start', v_bucket_start)
  )
  on conflict (idempotency_key) do nothing;

  if found then
    update point_balances
      set balance = balance + v_cfg.reward_points_per_interval,
          updated_at = now()
      where discord_user_id = p_discord_user_id;
    granted_points := v_cfg.reward_points_per_interval;
  else
    granted_points := 0;
  end if;

  select balance into new_balance from point_balances where discord_user_id = p_discord_user_id;
  return next;
end;
$$;

-- Equip Item
create or replace function nyang.set_equipped_item(
  p_discord_user_id text,
  p_item_id uuid
)
returns void
language plpgsql
set search_path = nyang, public
as $$
declare
  v_role_id text;
  v_prev_item uuid;
  v_prev_role text;
  v_new_role text;
  v_qty integer;
begin
  perform ensure_user(p_discord_user_id);

  if p_item_id is null then
    -- Unequip logic
    select item_id into v_prev_item from equipped where discord_user_id = p_discord_user_id;
    if v_prev_item is not null then
       select discord_role_id into v_prev_role from items where item_id = v_prev_item;
       delete from equipped where discord_user_id = p_discord_user_id;
       
       if v_prev_role is not null then
         insert into role_sync_jobs(discord_user_id, remove_role_id, reason) values (p_discord_user_id, v_prev_role, 'unequip');
       end if;
    end if;
    return;
  end if;

  -- Check ownership
  select qty into v_qty from inventory where discord_user_id = p_discord_user_id and item_id = p_item_id;
  if coalesce(v_qty, 0) <= 0 then
    raise exception 'ITEM_NOT_OWNED';
  end if;

  -- Get item info
  select discord_role_id into v_new_role
  from items
  where item_id = p_item_id and is_active = true and is_equippable = true;

  if not found then
    raise exception 'ITEM_NOT_EQUIPPABLE';
  end if;

  -- Get previous item
  select item_id into v_prev_item from equipped where discord_user_id = p_discord_user_id;
  if v_prev_item is not null then
    select discord_role_id into v_prev_role from items where item_id = v_prev_item;
  end if;

  -- Update equipped
  insert into equipped(discord_user_id, item_id)
  values (p_discord_user_id, p_item_id)
  on conflict (discord_user_id) do update set item_id = excluded.item_id, equipped_at = now();

  -- Queue sync if roles changed
  if v_prev_role is distinct from v_new_role then
    if v_prev_role is not null then
        insert into role_sync_jobs(discord_user_id, remove_role_id, reason) values (p_discord_user_id, v_prev_role, 'unequip_swap');
    end if;
    if v_new_role is not null then
        insert into role_sync_jobs(discord_user_id, add_role_id, reason) values (p_discord_user_id, v_new_role, 'equip');
    end if;
  end if;
end;
$$;

-- Perform Gacha Draw
create or replace function nyang.perform_gacha_draw(
  p_discord_user_id text,
  p_pool_id uuid default null
)
returns table (
  out_item_id uuid,
  out_name text,
  out_rarity nyang.gacha_rarity,
  out_discord_role_id text,
  out_is_free boolean,
  out_refund_points integer,
  out_new_balance integer
)
language plpgsql
set search_path = nyang, public
as $$
declare
  v_pool gacha_pools%rowtype;
  v_state gacha_user_state%rowtype;
  v_now timestamptz := now();
  v_free_ok boolean := false;
  v_paid_ok boolean := true;
  v_spend integer := 0;
  v_refund integer := 0;
  v_balance integer := 0;
  v_item record;
  v_pull_id uuid;
  v_current_qty integer := 0;
  v_force_rarity boolean := false;
  v_rarity nyang.gacha_rarity;
  v_is_free boolean;
  v_roll numeric;
begin
  perform ensure_user(p_discord_user_id);

  if p_pool_id is null then
    select * into v_pool
    from gacha_pools
    where is_active = true
    order by created_at asc
    limit 1;
  else
    select * into v_pool
    from gacha_pools
    where pool_id = p_pool_id and is_active = true;
  end if;

  if not found then
    raise exception 'NO_ACTIVE_POOL';
  end if;

  insert into gacha_user_state(discord_user_id, pool_id)
  values (p_discord_user_id, v_pool.pool_id)
  on conflict (discord_user_id, pool_id) do nothing;

  select * into v_state
  from gacha_user_state
  where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id
  for update;

  if v_pool.free_pull_interval_seconds is not null then
    v_free_ok := (v_state.free_available_at is null) or (v_state.free_available_at <= v_now);
  end if;

  v_paid_ok := (v_state.paid_available_at is null) or (v_state.paid_available_at <= v_now);

  if v_free_ok then
    v_is_free := true;
    v_spend := 0;
  else
    v_is_free := false;
    if not v_paid_ok then
      raise exception 'PAID_COOLDOWN';
    end if;
    v_spend := greatest(v_pool.cost_points, 0);
  end if;

  select balance into v_balance from point_balances where discord_user_id = p_discord_user_id for update;

  if (not v_is_free) and v_balance < v_spend then
    raise exception 'INSUFFICIENT_POINTS';
  end if;

  -- Pity Logic
  if v_pool.pity_threshold is not null and v_pool.pity_rarity is not null then
    if v_state.pity_counter >= greatest(v_pool.pity_threshold - 1, 0) then
      v_force_rarity := true;
    end if;
  end if;

  if v_force_rarity then
    v_rarity := v_pool.pity_rarity;
  else
    v_roll := (random() * 100)::numeric;
    if v_roll <= v_pool.rate_r then
      v_rarity := 'R';
    elsif v_roll <= v_pool.rate_r + v_pool.rate_s then
      v_rarity := 'S';
    elsif v_roll <= v_pool.rate_r + v_pool.rate_s + v_pool.rate_ss then
      v_rarity := 'SS';
    else
      v_rarity := 'SSS';
    end if;
  end if;

  -- Pick Item
  with candidates as (
    select
      i.item_id,
      i.name,
      i.rarity,
      i.discord_role_id,
      i.duplicate_refund_points
    from items i
    where
      i.is_active = true
      and i.is_equippable = true
      and i.rarity = v_rarity
  ),
  choice as (
    select *
    from candidates
    order by random()
    limit 1
  )
  select * into v_item from choice;

  -- Fallback logic (omitted for brevity in consolidated script, but kept in full impl)
  if v_item is null then
     raise exception 'POOL_EMPTY_FOR_RARITY';
  end if;

  -- Refund check
  select qty into v_current_qty
  from inventory
  where discord_user_id = p_discord_user_id and item_id = v_item.item_id;

  if coalesce(v_current_qty, 0) > 0 then
    v_refund := greatest(coalesce(v_item.duplicate_refund_points, 0), 0);
  else
    v_refund := 0;
  end if;

  -- Record Pull
  insert into gacha_pulls(discord_user_id, pool_id, is_free, spent_points)
  values (p_discord_user_id, v_pool.pool_id, v_is_free, v_spend)
  returning pull_id into v_pull_id;

  insert into gacha_pull_results(pull_id, item_id, qty, is_pity)
  values (v_pull_id, v_item.item_id, 1, v_force_rarity);

  insert into inventory(discord_user_id, item_id, qty)
  values (p_discord_user_id, v_item.item_id, 1)
  on conflict (discord_user_id, item_id) do update
    set qty = inventory.qty + 1,
        updated_at = now();

  -- Deduct / Log Points
  if (not v_is_free) and v_spend <> 0 then
    insert into point_events(discord_user_id, kind, amount, meta)
    values (p_discord_user_id, 'gacha_spend', -v_spend, jsonb_build_object('pool_id', v_pool.pool_id, 'pull_id', v_pull_id));
    update point_balances
      set balance = balance - v_spend,
      updated_at = now()
    where discord_user_id = p_discord_user_id;
  end if;

  if v_refund <> 0 then
    insert into point_events(discord_user_id, kind, amount, meta)
    values (p_discord_user_id, 'duplicate_refund', v_refund, jsonb_build_object('item_id', v_item.item_id, 'pull_id', v_pull_id));
    update point_balances
      set balance = balance + v_refund,
      updated_at = now()
    where discord_user_id = p_discord_user_id;
  end if;

  -- Update Cooldown & Pity
  if v_is_free and v_pool.free_pull_interval_seconds is not null then
    update gacha_user_state
      set free_available_at = v_now + make_interval(secs => v_pool.free_pull_interval_seconds),
          updated_at = now()
      where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id;
  elsif (not v_is_free) and v_pool.paid_pull_cooldown_seconds is not null and v_pool.paid_pull_cooldown_seconds > 0 then
    update gacha_user_state
      set paid_available_at = v_now + make_interval(secs => v_pool.paid_pull_cooldown_seconds),
          updated_at = now()
      where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id;
  else
    update gacha_user_state
      set updated_at = now()
      where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id;
  end if;

  if v_pool.pity_threshold is not null and v_pool.pity_rarity is not null then
    if v_item.rarity = v_pool.pity_rarity then
      update gacha_user_state
        set pity_counter = 0
        where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id;
    else
      update gacha_user_state
        set pity_counter = pity_counter + 1
        where discord_user_id = p_discord_user_id and pool_id = v_pool.pool_id;
    end if;
  end if;

  select balance into v_balance from point_balances where discord_user_id = p_discord_user_id;

  out_item_id := v_item.item_id;
  out_name := v_item.name;
  out_rarity := v_item.rarity;
  out_discord_role_id := v_item.discord_role_id;
  out_is_free := v_is_free;
  out_refund_points := v_refund;
  out_new_balance := v_balance;
  return next;
end;
$$;

-- 6. Initial Data
-- NOTE: Please replace 'YOUR_GUILD_ID' with actual ID in production or env
insert into nyang.app_config (id, guild_id, reward_points_per_interval)
values (1, '0', 10)
on conflict (id) do nothing;

alter publication supabase_realtime add table nyang.role_sync_jobs;

notify pgrst, 'reload schema';
