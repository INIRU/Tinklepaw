alter table nyang.app_config
  add column if not exists stock_holding_fee_enabled boolean not null default true,
  add column if not exists stock_holding_fee_daily_bps integer not null default 8,
  add column if not exists stock_holding_fee_daily_cap_bps integer not null default 20,
  add column if not exists stock_holding_fee_last_applied_on date,
  add column if not exists stock_holding_fee_timezone text not null default 'Asia/Seoul';

do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conrelid = 'nyang.app_config'::regclass
      and conname = 'app_config_stock_holding_fee_daily_bps_check'
  ) then
    alter table nyang.app_config
      add constraint app_config_stock_holding_fee_daily_bps_check
      check (stock_holding_fee_daily_bps between 1 and 1000);
  end if;

  if not exists (
    select 1
    from pg_constraint
    where conrelid = 'nyang.app_config'::regclass
      and conname = 'app_config_stock_holding_fee_daily_cap_bps_check'
  ) then
    alter table nyang.app_config
      add constraint app_config_stock_holding_fee_daily_cap_bps_check
      check (
        stock_holding_fee_daily_cap_bps between 1 and 2000
        and stock_holding_fee_daily_cap_bps >= stock_holding_fee_daily_bps
      );
  end if;
end
$$;

create table if not exists nyang.stock_holding_fee_events (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  fee_date date not null,
  discord_user_id text not null references nyang.users(discord_user_id) on delete cascade,
  holding_qty bigint not null,
  mark_price integer not null,
  holding_value bigint not null,
  fee_bps integer not null,
  fee_amount integer not null,
  balance_after integer not null,
  metadata jsonb not null default '{}'::jsonb
);

create index if not exists idx_stock_holding_fee_events_user_created
  on nyang.stock_holding_fee_events (discord_user_id, created_at desc);

create index if not exists idx_stock_holding_fee_events_date
  on nyang.stock_holding_fee_events (fee_date desc, created_at desc);

create or replace function nyang.get_stock_dashboard(p_discord_user_id text)
returns table(
  out_symbol text,
  out_display_name text,
  out_price integer,
  out_change_pct numeric,
  out_fee_bps integer,
  out_balance integer,
  out_holding_qty integer,
  out_holding_avg_price integer,
  out_holding_value bigint,
  out_unrealized_pnl bigint,
  out_candles jsonb
)
language plpgsql
security definer
set search_path = nyang, public
as $$
declare
  v_market nyang.stock_market%rowtype;
  v_balance integer;
  v_holding nyang.stock_holdings%rowtype;
  v_prev_close integer;
  v_change_pct numeric := 0;
begin
  perform nyang.ensure_user(p_discord_user_id);
  perform nyang.sync_stock_market(now());

  insert into nyang.point_balances (discord_user_id, balance)
  values (p_discord_user_id, 0)
  on conflict (discord_user_id) do nothing;

  insert into nyang.stock_holdings (discord_user_id, qty, avg_price)
  values (p_discord_user_id, 0, 0)
  on conflict (discord_user_id) do nothing;

  select *
  into v_market
  from nyang.stock_market
  where id = 1;

  select pb.balance
  into v_balance
  from nyang.point_balances pb
  where pb.discord_user_id = p_discord_user_id;

  select *
  into v_holding
  from nyang.stock_holdings sh
  where sh.discord_user_id = p_discord_user_id;

  select c.close_price
  into v_prev_close
  from nyang.stock_candles c
  order by c.bucket_start desc
  offset 1
  limit 1;

  if v_prev_close is not null and v_prev_close > 0 then
    v_change_pct := round((v_market.current_price - v_prev_close)::numeric * 100.0 / v_prev_close, 2);
  end if;

  return query
  with candles as (
    select c.bucket_start, c.open_price, c.high_price, c.low_price, c.close_price, c.volume_buy, c.volume_sell
    from nyang.stock_candles c
    order by c.bucket_start desc
    limit 72
  )
  select
    v_market.symbol,
    v_market.display_name,
    v_market.current_price,
    v_change_pct,
    v_market.fee_bps,
    v_balance,
    v_holding.qty::integer,
    v_holding.avg_price,
    (v_holding.qty::bigint * v_market.current_price::bigint),
    (v_holding.qty::bigint * (v_market.current_price - v_holding.avg_price)::bigint),
    coalesce(
      (
        select jsonb_agg(
          jsonb_build_object(
            't', x.bucket_start,
            'o', x.open_price,
            'h', x.high_price,
            'l', x.low_price,
            'c', x.close_price,
            'vb', x.volume_buy,
            'vs', x.volume_sell
          )
          order by x.bucket_start
        )
        from candles x
      ),
      '[]'::jsonb
    );
end
$$;

create or replace function nyang.trade_stock(
  p_discord_user_id text,
  p_side text,
  p_qty integer
)
returns table(
  out_success boolean,
  out_error_code text,
  out_side text,
  out_price integer,
  out_qty integer,
  out_gross bigint,
  out_fee bigint,
  out_settlement bigint,
  out_new_balance integer,
  out_holding_qty integer,
  out_holding_avg_price integer,
  out_unrealized_pnl bigint
)
language plpgsql
security definer
set search_path = nyang, public
as $$
declare
  v_side text := lower(coalesce(p_side, ''));
  v_market nyang.stock_market%rowtype;
  v_balance nyang.point_balances%rowtype;
  v_holding nyang.stock_holdings%rowtype;
  v_bucket timestamptz := nyang.stock_bucket_start(now());
  v_pre_price integer;
  v_new_price integer;
  v_exec_price integer;
  v_impact_bps integer;
  v_price_delta integer;
  v_gross bigint;
  v_fee bigint;
  v_total_cost bigint;
  v_settlement bigint;
  v_new_qty integer;
  v_new_avg integer;
  v_new_balance integer;
begin
  if p_qty is null or p_qty <= 0 then
    return query select false, 'INVALID_QTY', v_side, 0, coalesce(p_qty, 0), 0, 0, 0, 0, 0, 0, 0;
    return;
  end if;

  if p_qty > 1000000 then
    return query select false, 'QTY_TOO_LARGE', v_side, 0, p_qty, 0, 0, 0, 0, 0, 0, 0;
    return;
  end if;

  if v_side not in ('buy', 'sell') then
    return query select false, 'INVALID_SIDE', v_side, 0, p_qty, 0, 0, 0, 0, 0, 0, 0;
    return;
  end if;

  perform nyang.ensure_user(p_discord_user_id);
  perform nyang.sync_stock_market(now());

  insert into nyang.point_balances (discord_user_id, balance)
  values (p_discord_user_id, 0)
  on conflict (discord_user_id) do nothing;

  insert into nyang.stock_holdings (discord_user_id, qty, avg_price)
  values (p_discord_user_id, 0, 0)
  on conflict (discord_user_id) do nothing;

  select *
  into v_market
  from nyang.stock_market
  where id = 1
  for update;

  select *
  into v_balance
  from nyang.point_balances
  where discord_user_id = p_discord_user_id
  for update;

  select *
  into v_holding
  from nyang.stock_holdings
  where discord_user_id = p_discord_user_id
  for update;

  v_pre_price := greatest(1, v_market.current_price);
  v_impact_bps := least(320, greatest(12, ceil(sqrt(p_qty::numeric) * 12)::integer));
  v_price_delta := greatest(1, round(v_pre_price::numeric * (v_impact_bps::numeric / 10000.0))::integer);

  if v_side = 'buy' then
    v_new_price := v_pre_price + v_price_delta;
  else
    v_new_price := greatest(50, v_pre_price - v_price_delta);
  end if;

  v_exec_price := greatest(1, round((v_pre_price::numeric + v_new_price::numeric) / 2.0)::integer);
  v_gross := v_exec_price::bigint * p_qty::bigint;
  v_fee := greatest(1::bigint, floor(v_gross::numeric * (v_market.fee_bps::numeric / 10000.0))::bigint);

  if v_side = 'buy' then
    v_total_cost := v_gross + v_fee;

    if v_balance.balance::bigint < v_total_cost then
      return query
      select false, 'INSUFFICIENT_POINTS', v_side, v_exec_price, p_qty, v_gross, v_fee, v_total_cost,
             v_balance.balance, v_holding.qty::integer, v_holding.avg_price,
             (v_holding.qty::bigint * (v_exec_price - v_holding.avg_price)::bigint);
      return;
    end if;

    v_new_balance := v_balance.balance - v_total_cost::integer;
    v_new_qty := (v_holding.qty + p_qty)::integer;
    if v_new_qty > 0 then
      v_new_avg := floor(((v_holding.qty::numeric * v_holding.avg_price::numeric) + (p_qty::numeric * v_exec_price::numeric)) / v_new_qty::numeric)::integer;
    else
      v_new_avg := 0;
    end if;

    update nyang.point_balances
    set balance = v_new_balance
    where discord_user_id = p_discord_user_id;

    update nyang.stock_holdings
    set qty = v_new_qty,
        avg_price = v_new_avg,
        updated_at = now()
    where discord_user_id = p_discord_user_id;

    insert into nyang.point_events (discord_user_id, kind, amount, meta)
    values (
      p_discord_user_id,
      'stock_buy_spend',
      -v_total_cost,
      jsonb_build_object(
        'qty', p_qty,
        'price', v_exec_price,
        'gross', v_gross,
        'fee', v_fee,
        'impact_bps', v_impact_bps,
        'pre_price', v_pre_price,
        'post_price', v_new_price
      )
    );

    v_settlement := v_total_cost;
  else
    if v_holding.qty < p_qty then
      return query
      select false, 'INSUFFICIENT_HOLDINGS', v_side, v_exec_price, p_qty, v_gross, v_fee, 0,
             v_balance.balance, v_holding.qty::integer, v_holding.avg_price,
             (v_holding.qty::bigint * (v_exec_price - v_holding.avg_price)::bigint);
      return;
    end if;

    v_settlement := v_gross - v_fee;
    v_new_balance := v_balance.balance + v_settlement::integer;
    v_new_qty := (v_holding.qty - p_qty)::integer;
    v_new_avg := case when v_new_qty = 0 then 0 else v_holding.avg_price end;

    update nyang.point_balances
    set balance = v_new_balance
    where discord_user_id = p_discord_user_id;

    update nyang.stock_holdings
    set qty = v_new_qty,
        avg_price = v_new_avg,
        updated_at = now()
    where discord_user_id = p_discord_user_id;

    insert into nyang.point_events (discord_user_id, kind, amount, meta)
    values (
      p_discord_user_id,
      'stock_sell_gain',
      v_settlement,
      jsonb_build_object(
        'qty', p_qty,
        'price', v_exec_price,
        'gross', v_gross,
        'fee', v_fee,
        'impact_bps', v_impact_bps,
        'pre_price', v_pre_price,
        'post_price', v_new_price
      )
    );
  end if;

  insert into nyang.stock_candles (
    bucket_start,
    open_price,
    high_price,
    low_price,
    close_price,
    volume_buy,
    volume_sell
  )
  values (
    v_bucket,
    v_pre_price,
    greatest(v_pre_price, v_new_price),
    least(v_pre_price, v_new_price),
    v_new_price,
    case when v_side = 'buy' then p_qty else 0 end,
    case when v_side = 'sell' then p_qty else 0 end
  )
  on conflict (bucket_start) do nothing;

  update nyang.stock_candles
  set high_price = greatest(high_price, v_pre_price, v_new_price),
      low_price = least(low_price, v_pre_price, v_new_price),
      close_price = v_new_price,
      volume_buy = volume_buy + case when v_side = 'buy' then p_qty else 0 end,
      volume_sell = volume_sell + case when v_side = 'sell' then p_qty else 0 end
  where bucket_start = v_bucket;

  update nyang.stock_market
  set current_price = v_new_price,
      updated_at = now()
  where id = 1;

  return query
  select
    true,
    null::text,
    v_side,
    v_exec_price,
    p_qty,
    v_gross,
    v_fee,
    v_settlement,
    v_new_balance,
    v_new_qty,
    v_new_avg,
    (v_new_qty::bigint * (v_exec_price - v_new_avg)::bigint);
end
$$;

create or replace function nyang.apply_daily_stock_holding_fee(p_now timestamptz default now())
returns table(
  out_applied boolean,
  out_fee_date date,
  out_charged_users integer,
  out_total_fee bigint
)
language plpgsql
security definer
set search_path = nyang, public
as $$
declare
  v_cfg nyang.app_config%rowtype;
  v_market nyang.stock_market%rowtype;
  v_tz text;
  v_fee_date date;
  v_fee_bps integer;
  v_fee_cap_bps integer;
  v_charged_users integer := 0;
  v_total_fee bigint := 0;
  v_row record;
  v_balance_before integer;
  v_balance_after integer;
  v_holding_value bigint;
  v_fee_raw bigint;
  v_fee_cap bigint;
  v_fee_amount integer;
  v_actual_fee integer;
begin
  perform nyang.sync_stock_market(p_now);

  select *
  into v_cfg
  from nyang.app_config
  where id = 1
  for update;

  v_tz := coalesce(nullif(v_cfg.stock_holding_fee_timezone, ''), 'Asia/Seoul');
  v_fee_date := (p_now at time zone v_tz)::date;

  if not coalesce(v_cfg.stock_holding_fee_enabled, true) then
    return query select false, v_fee_date, 0, 0::bigint;
    return;
  end if;

  if v_cfg.stock_holding_fee_last_applied_on is not null
     and v_cfg.stock_holding_fee_last_applied_on >= v_fee_date then
    return query select false, v_fee_date, 0, 0::bigint;
    return;
  end if;

  v_fee_bps := greatest(1, least(1000, coalesce(v_cfg.stock_holding_fee_daily_bps, 8)));
  v_fee_cap_bps := greatest(v_fee_bps, least(2000, coalesce(v_cfg.stock_holding_fee_daily_cap_bps, 20)));

  select *
  into v_market
  from nyang.stock_market
  where id = 1
  for update;

  for v_row in
    select sh.discord_user_id, sh.qty::bigint as qty
    from nyang.stock_holdings sh
    where sh.qty > 0
  loop
    insert into nyang.point_balances (discord_user_id, balance)
    values (v_row.discord_user_id, 0)
    on conflict (discord_user_id) do nothing;

    select pb.balance
    into v_balance_before
    from nyang.point_balances pb
    where pb.discord_user_id = v_row.discord_user_id
    for update;

    v_holding_value := v_row.qty * v_market.current_price::bigint;
    v_fee_raw := floor(v_holding_value::numeric * (v_fee_bps::numeric / 10000.0))::bigint;
    v_fee_cap := floor(v_holding_value::numeric * (v_fee_cap_bps::numeric / 10000.0))::bigint;
    v_fee_amount := greatest(1, least(v_fee_raw, v_fee_cap))::integer;
    v_actual_fee := least(v_balance_before, v_fee_amount);

    if v_actual_fee <= 0 then
      continue;
    end if;

    v_balance_after := v_balance_before - v_actual_fee;

    update nyang.point_balances
    set balance = v_balance_after
    where discord_user_id = v_row.discord_user_id;

    insert into nyang.point_events (discord_user_id, kind, amount, meta)
    values (
      v_row.discord_user_id,
      'stock_holding_fee',
      -v_actual_fee,
      jsonb_build_object(
        'fee_date', v_fee_date,
        'holding_qty', v_row.qty,
        'mark_price', v_market.current_price,
        'holding_value', v_holding_value,
        'fee_bps', v_fee_bps,
        'fee_cap_bps', v_fee_cap_bps,
        'fee_requested', v_fee_amount,
        'fee_charged', v_actual_fee
      )
    );

    insert into nyang.stock_holding_fee_events (
      fee_date,
      discord_user_id,
      holding_qty,
      mark_price,
      holding_value,
      fee_bps,
      fee_amount,
      balance_after,
      metadata
    )
    values (
      v_fee_date,
      v_row.discord_user_id,
      v_row.qty,
      v_market.current_price,
      v_holding_value,
      v_fee_bps,
      v_actual_fee,
      v_balance_after,
      jsonb_build_object(
        'fee_cap_bps', v_fee_cap_bps,
        'fee_requested', v_fee_amount,
        'timezone', v_tz
      )
    );

    v_charged_users := v_charged_users + 1;
    v_total_fee := v_total_fee + v_actual_fee;
  end loop;

  update nyang.app_config
  set stock_holding_fee_last_applied_on = v_fee_date
  where id = 1;

  return query select true, v_fee_date, v_charged_users, v_total_fee;
end
$$;

grant execute on function nyang.apply_daily_stock_holding_fee(timestamptz) to service_role;
